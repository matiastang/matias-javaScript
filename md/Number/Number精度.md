<!--
 * @Author: tangdaoyong
 * @Date: 2021-04-20 14:15:20
 * @LastEditors: matiastang
 * @LastEditTime: 2023-07-03 12:02:18
 * @Description: Number精度
-->
# Number精度

## 参考

[JS Number精度](https://blog.csdn.net/weixin_39786850/article/details/110746250)

## 介绍

`Number`遵循 `[IEEE 754](https://zh.wikipedia.org/wiki/IEEE_754)` 规范：

* 先把Number转成二进制科学计数法表示；
* 然后用64位bit存储二进制科学计算法的相关参数。

IEEE 754-背景
IEEE二进制浮点数算术标准（IEEE 754）是20世纪80年代以来最广泛使用的浮点数运算标准，为许多CPU与浮点运算器所采用。这个标准定义了表示浮点数的格式（包括负零-0）与反常值（denormal number），一些特殊数值（（无穷（Inf）与非数值（NaN）），以及这些数值的“浮点数运算符”；它也指明了四种数值舍入规则和五种例外状况（包括例外发生的时机与处理方式）。

IEEE 754规定了四种表示浮点数值的方式：单精确度（32位）、双精确度（64位）、延伸单精确度（43比特以上，很少使用）与延伸双精确度（79比特以上，通常以80位实现）。只有32位模式有强制要求，其他都是选择性的。大部分编程语言都提供了IEEE浮点数格式与算术，但有些将其列为非必需的。例如，IEEE 754问世之前就有的C语言，现在包括了IEEE算术，但不算作强制要求（C语言的float通常是指IEEE单精确度，而double是指双精确度）。

该标准的全称为IEEE二进制浮点数算术标准（ANSI/IEEE Std 754-1985），又称IEC 60559:1989，微处理器系统的二进制浮点数算术

wiki 上 CV 过来的官方话语
该标准规定了四种表示浮点数值的方式，优点是可以归一化处理整数和小数。javascript 对 number 数值的表示方式则采用了其中的双精确度（64位）的表示方式，所以 javascript 中所有的数值都是 number 类型，因为它既可以表示浮点数值，也可以表示整数。

下面讲解 IEEE 754 规范都将以双精度（64位）为例，着重讲解 javascript 中是如何对数字进行存储的转换的。

理解 IEEE 754 规范的前置知识
十进制转为二进制方法
拿 173.8125 举例如何将之转化为二进制小数。

①. 针对整数部分 173，采取除 2 取余，逆序排列;

173 / 2 = 86 ... 1
86 / 2 = 43 ... 0
43 / 2 = 21 ... 1   ↑
21 / 2 = 10 ... 1   | 逆序排列
10 / 2 = 5 ... 0    |
5 / 2 = 2 ... 1     |
2 / 2 = 1 ... 0
1 / 2 = 0 ... 1
得整数部分的二进制为 10101101。

②. 针对小数部分 0.8125，采用乘 2 取整，顺序排列;

0.8125 * 2 = 1.625  |
0.625 * 2 = 1.25    | 顺序排列
0.25 * 2 = 0.5      |
0.5 * 2 = 1         ↓
得小数部分的二进制为 1101

③. 将前面两部的结果相加，结果为 10101101.1101

二进制转为十进制方法
以二进制 10101101.1101 为例

①. 针对整数部分 10101101 计算逻辑如下：

// 10101101
// ← 从右往左
1 * 2^0 + 0 * 2^1 + 1 * 2^2 + 1 * 2^3 + 0 * 2^4 + 1 * 2^5 + 0 * 2^6 + 1 * 2^7
= 1 + 0 + 4 + 8 + 0 + 32 + 0 + 128
= 173
②. 小数部分 1101 计算逻辑如下

// 1101
// 从左往右 →
1 * 2^-1 + 1 * 2^-2 + 0 * 2^-3 + 1 * 2^-4
= 1/2 + 1/4 + 0 + 1/16
= 13/16
= 0.8125
③. 最后将整数部分跟小数部分相加得到最终结果 173.8125

科学计数法
①. 十进制 173.8125 的科学计数法为 1.738125 * 10^2

②. 十进制 173.8125 对应的二进制 10101101.1101，进一步可以使用二进制的科学计数法来表示，对应的二进制科学计数法为 1.01011011101 * 2^7。跟十进制类似，将底数 10 换为了 2，7 则代表小数点往右多少位。

重点：1.01011011101 * 2^7 为二进制，将其转换为 10 进制的过程为，先将 1.01011011101 做为 2 进制转换为 10 进制，得到 1.35791015625，然后将其乘以 2^7 （也就是 1.35791015625 * 128），最后得到的十进制为 173.8125

“浮点数”是一种表示数字的标准，整数也可以用浮点数的格式来存储

我们也可以理解成，浮点数就是小数

在JavaScript中，现在主流的数值类型是Number，而Number采用的是IEEE754规范中64位双精度浮点数编码

这样的存储结构优点是可以归一化处理整数和小数，节省存储空间

对于一个整数，可以很轻易转化成十进制或者二进制。但是对于一个浮点数来说，因为小数点的存在，小数点的位置不是固定的。解决思路就是使用科学计数法，这样小数点位置就固定了

而计算机只能用二进制（0或1）表示，二进制转换为科学记数法的公式如下：

X = a * 2^e

其中，a的值为0或者1，e为小数点移动的位置

举个例子：

27.0转化成二进制为11011.0 ，科学计数法表示为：

1.10110 * 2^4

前面讲到，javaScript存储方式是双精度浮点数，其长度为8个字节，即64位比特

64位比特又可分为三个部分：

* 符号位S：第 1 位是正负数符号位（sign），0代表正数，1代表负数
* 指数位E：中间的 11 位存储指数（exponent），用来表示次方数，可以为正负数。在双精度浮点数中，指数的固定偏移量为`1023`
* 尾数位M：最后的 52 位是尾数（mantissa），超出的部分自动进一舍零

以前一直有两个疑问：

1. 指数位为什么要固定偏移`1023`
2. 指数位为什么是11位，尾数位才52位，偏移量用不了11啊

关于固定偏移：
指数部分即使用所谓的偏正值形式表示，偏正值为实际的指数大小与一个固定值（64位的情况是1023）的和。采用这种方式表示的目的是简化比较。因为，指数的值可能为正也可能为负，如果采用补码表示的话，全体符号位S和Exp自身的符号位将导致不能简单的进行大小比较。正因为如此，指数部分通常采用一个无符号的正数值存储。双精度的指数部分是−1022～+1023加上1023，指数值的大小从1～2046（0（2进位全为0）和2047（2进位全为1）是特殊值）。浮点小数计算时，指数值减去偏正值将是实际的指数大小。
浮点数的比较
浮点数基本上可以按照符号位、指数域、尾数域的顺序作字典比较。显然，所有正数大于负数；正负号相同时，指数的二进制表示法更大的其浮点数值更大。


64位bit分为三个部分:

* 符号位S：第 1 位是正负数符号位（sign），0代表正数，1代表负数
* 指数位E：中间的 11 位存储指数（exponent），用来表示次方数
* 尾数位M：最后的 52 位是尾数（mantissa），超出的部分自动进一舍
![Number内存示意图mat](../imgs/number.png)
![Number数学计算公式](../imgs/number-math.png)

27.5 转换为二进制11011.1

11011.1转换为科学记数法

符号位为1(正数)，指数位为4+，1023+4，即1027

因为它是十进制的需要转换为二进制，即 10000000011，小数部分为10111，补够52位即： 1011 1000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000`

所以27.5存储为计算机的二进制标准形式（符号位+指数位+小数部分 (阶数)），既下面所示

0+10000000011+011 1000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000`

比如：十进制数字`4.5`转成二进制就是 `100.1`，二进制的科学计数法表示就是`1.001*2^2`。
此时`M = 1001`，但是因为二进制科学计数法的尾数`M`的第一位固定的`1`，所以可以直接省去（这样可以节省一个bit，导致`M`最多可以表示`53`位），即最终`M = 001`。

1. 为什么`Number`的最大整数是`2 ^ 53 -1`呢?
整数需要连续性，所以表示整数时不能使用指数位E区域，只有尾数`M`区域可表示连续的数据，上面说了其实`M`最多可以表示`53`位。所以最大的安全整数是`2 ^ 53 -1`。大于 `9007199254740992` 的可能会丢失精度。`Number.MAX_SAFE_INTEGER`为`9007199254740991`。
1. `Array`索引既然是整数,那它的最大索引为什么不是`2 ^ 53 - 1`呢
`JS`语言中数组的索引最大就是`2^32 -1`。就当做语言规范吧，背后的原因不清楚。除了数组索引，还有其他的地方采用`32bit`整数：

* 位运算
* `setTimeout/setInterval`的`delay`参数也是必须是`32`整数

数组的最大长度是2的32次方减1，这个不是指数组只能存2^32-1位数据，也不是说数组的下标最大值就是2^32-1，而是指数组的`length`属性最大值为`2^32-1`。

`ECMAScript` 标准约定`number`数字需要被当成 `64` 位双精度浮点数处理，但事实上，一直使用 `64` 位去存储任何数字实际是非常低效的，所以 `JavaScript` 引擎并不总会使用 `64` 位去存储数字，引擎会在内部采用其他内存表示方式，如 `32` 位。

## 思考

`JS`和`toFixed`也能看到实际的值。`toFixed()` 方法可把 `Number` 四舍五入为指定小数位数的数字。
```js
Number.MAX_SAFE_INTEGER.toFixed(64)
"9007199254740991.0000000000000000000000000000000000000000000000000000000000000000"
Number.MAX_SAFE_INTEGER
9007199254740991
(0.1).toFixed(64)
"0.1000000000000000055511151231257827021181583404541015625000000000"
(0.2).toFixed(64)
"0.2000000000000000111022302462515654042363166809082031250000000000"
(0.1 + 0.2).toFixed(64)
"0.3000000000000000444089209850062616169452667236328125000000000000"
0.1 + 0.2 == 0.3
false
```
`0.1 + 0.2 不等于 0.3`原因很简单，因为0.1存储的值比实际值大了一点，0.2也是大了一点（差值比0.1大一倍），两个相加就大很多了，多出来的就是那个尾巴。为什么0.1不能够被准确存储呢？因为计算机都是二进制的，在十进制能表示的数不一定能被二进制精确表示，就好像在十进制里面无法准确表示1/3一样，而在三进制里面0.1便表示1/3了。在二进制里面能够被精确表示都必须得是二的倍数的组合，如二进制的`0.1`表示十进制的`0.5`，`0.11`便表示`0.75（ = 0.5 + 0.25）`，`0.111`表示`0.875（ = 0.5 + 0.25 + 0.125）`，假设现在要存储0.625那么能够被精确表示为二进制的0.101，如果要表示`0.626`呢？那么应该是通过后面的小数位相加拼凑，让其尽可能逼近`0.626`. 这个时候就不是精确表示了，这个事情就是编译器的工作。


下面等式成立
```js
Number.MAX_SAFE_INTEGER + 1 === Number.MAX_SAFE_INTEGER + 2
```
超出了最大安全范围
```js
(Number.MAX_SAFE_INTEGER + 1).toFixed(64)
"9007199254740992.0000000000000000000000000000000000000000000000000000000000000000"
(Number.MAX_SAFE_INTEGER + 2).toFixed(64)
"9007199254740992.0000000000000000000000000000000000000000000000000000000000000000"
(Number.MAX_SAFE_INTEGER + 3).toFixed(64)
"9007199254740994.0000000000000000000000000000000000000000000000000000000000000000"
(Number.MAX_SAFE_INTEGER + 4).toFixed(64)
"9007199254740996.0000000000000000000000000000000000000000000000000000000000000000"
(Number.MAX_SAFE_INTEGER + 5).toFixed(64)
"9007199254740996.0000000000000000000000000000000000000000000000000000000000000000"
(Number.MAX_SAFE_INTEGER + 6).toFixed(64)
"9007199254740996.0000000000000000000000000000000000000000000000000000000000000000"
(Number.MAX_SAFE_INTEGER + 7).toFixed(64)
"9007199254740998.0000000000000000000000000000000000000000000000000000000000000000"
```

## 大数问题解决

* decimal.js 字符串的形式计算
* BigInt 新类型，字符串n结尾