<!--
 * @Descripttion: 
 * @version: 
 * @Author: matias tang
 * @Date: 2020-09-17 11:10:37
 * @LastEditors: matias tang
 * @LastEditTime: 2020-09-17 16:10:23
-->
<!-- TOC -->

- [前端路由](#前端路由)
  - [介绍](#介绍)
  - [hash模式](#hash模式)
  - [history模式](#history模式)

<!-- /TOC -->
# 前端路由

## 介绍

前端路由有2种模式，第一种是hash模式，第二种是history模式。

## hash模式

hash路由模式是这样的：http://www.baidu.com/#/xx。 有带#号，后面就是hash值的变化。改变后面的hash值，它不会向服务器发出请求，因此也就不会刷新页面。并且每次hash值发生改变的时候，会触发hashchange事件。因此我们可以通过监听该事件，来知道hash值发生了哪些变化。比如我们可以如下简单的监听：
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>路由hash</title>

    <script src="../JS/UUID.js"></script>
    <script src="../JS/hashTest.js"></script>
</head>
<body>
    <button onclick="changeHash()">改变hash</button>
</body>
</html>
```
```js
function hashUpdate (e) {
    // todo 匹配 hash 做 dom 更新操作
    console.log(e)
    console.log(`herf=${window.location.href}`)
    console.log(`hash=${window.location.hash}`)
}

window.addEventListener('hashchange', hashUpdate);

function changeHash(e){
    console.log(e)
    window.location.hash = uuid()
}
```
location.href 改变url后并不会刷新页面(只改变hash部分)
改变hash不会触发页面跳转，因为hash链接是当前页面中的某个片段，所以如果hash有变化，那么页面将会滚动到hash所连接的位置。

1. hash只能修改url的片段标识符的部分。并且必须从#号开始。
2. hash必须和原先的值不同，才能新增会话浏览历史的记录。

hash模式的特点：
hash模式在浏览器地址栏中url有#号这样的，比如(http://localhost:3001/#/a). # 后面的内容不会传给服务端，也就是说不会重新刷新页面。并且路由切换的时候也不会重新加载页面。
   
## history模式

HTML5的History API为浏览器的全局history对象增加了该扩展方法。它是一个浏览器的一个接口，在window对象中提供了onpopstate事件来监听历史栈的改变，只要历史栈有信息发生改变的话，就会触发该事件。
history提供了两个操作历史栈的API: history.pushState 和 history.replaceState

history.pushState(data[,title][,url]); // 向历史记录中追加一条记录
history.replaceState(data[,title][,url]); // 替换当前页在历史记录中的信息。

如上html5中新增了上面这两个方法，该两个方法也可以改变url，页面也不会重新刷新。
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>路由history</title>

    <script src="../JS/UUID.js"></script>
    <script src="../JS/MTTEST/historyTest.js"></script>
</head>
<body>
    <button onclick="changeHistory()">改变history</button>
</body>
</html>
```
```js
function popStateChange (e) {
    // todo 匹配 hash 做 dom 更新操作
    console.log(e)
    console.log(`herf=${window.location.href}`)
    console.log(`hash=${window.location.hash}`)
}

window.addEventListener('popstate', popStateChange);

function changeHistory(e){
    console.log(e)
    const state = { 'page_id': 1, 'user_id': 5 }
    const title = ''
    const url = `${window.location.origin}${window.location.pathname}#${uuid()}`
    window.history.pushState(state, title, url)
}
```

1. pushState能修改路径、查询参数和片段标识符。pushState比hash更符合前端路由的访问方式，更加优雅(因为不带#号)。
2. pushState可以新增相同的url的记录。

history模式的特点：
浏览器地址没有#， 比如(http://localhost:3001/a); 它也一样不会刷新页面的。但是url地址会改变。

[自定义路由](https://www.cnblogs.com/tugenhua0707/p/10859214.html)